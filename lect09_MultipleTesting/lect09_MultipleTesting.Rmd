---
title: "<font color=red> Lecture 9 -- Multiple Testing</font>"
subtitle: "STAT/BIOF/GSAT 540: Statistical Methods for High Dimensional Biology"
author: Keegan Korthauer
date: "2020/02/03 <br><br><font size=5> Slides by:  Keegan Korthauer with contributions from Gabriela Cohen Freue, Jenny Bryan, and Sara Mostafavi </font>"
output:
  xaringan::moon_reader:
    self_contained: true
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      highlightSpans: true
      countIncrementalSlides: false
      ratio: "16:9"
editor_options: 
  chunk_output_type: console
---

layout: true

<big>

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>

```{r, include = FALSE}
knitr::opts_chunk$set(tidy = FALSE, tidy.opts=list(width.cutoff=80), fig.retina=3)
ggplot2::theme_set(ggplot2::theme_bw(base_size = 20))
ggplot2::update_geom_defaults("point", list(size = 3))
```

```{r wrap-hook, include=FALSE}
library(knitr)
hook_output = knit_hooks$get('output')
knit_hooks$set(output = function(x, options) {
  # this hook is used only when the linewidth option is not NULL
  if (!is.null(n <- options$linewidth)) {
    x = knitr:::split_lines(x)
    # any lines wider than n should be wrapped
    if (any(nchar(x) > n)) x = strwrap(x, width = n)
    x = paste(x, collapse = '\n')
  }
  
  lines <- options$output.lines
   if (is.null(lines)) {
     return(hook_output(x, options))  # pass to default hook
   }
   x <- unlist(strsplit(x, "\n"))
   if (length(lines)==1) {        # first n lines
     if (length(x) > lines) {
       # truncate the output
       x <- c(head(x, lines))
     }
   } else {
     x <- c(x[lines])
   }
   # paste these lines together
   x <- paste(c(x, ""), collapse = "\n")

  hook_output(x, options)
})

```


```{css, echo = FALSE}
.remark-code, .remark-inline-code {
  background: #f0f0f0;
}
.remark-code {
  font-size: 20px;
}
.huge .remark-code { /*Change made here*/
  font-size: 200% !important;
}
.tiny .remark-code { /*Change made here*/
  font-size: 60% !important;
}
.small .remark-code { /*Change made here*/
  font-size: 90% !important;
}
.smaller .remark-code { /*Change made here*/
  font-size: 80% !important;
}
```


---

# The hybrid estimator in `limma`

 $$\tilde{s}^2_g = \frac{d_0s_0^2 + ds^2_g}{d_0 + d}$$

* recall that $(s_0, d_0)$ are the *prior* parameters for $\sigma^2_g$:

$$\frac{1}{\sigma^2_g} \sim \frac{1}{d_0s_0^2} \chi^2_{d_0}$$

* the exact estimation formulas for $(s_0, d_0)$ and their derivations are beyond the scope of the course (but `limma` takes care of the details for us)

* note that $(s_0, d_0)$ do not depend on $g$ 

---

# `limma` quickstart

$$\mathbf{Y}_g = \mathbf{X} \boldsymbol\alpha_g + \boldsymbol\varepsilon_g,$$
$$E(\boldsymbol\varepsilon_g) = 0, \,\, Var(\boldsymbol\varepsilon_g) = \sigma^2_g, \,\,\varepsilon_{ig} \perp \varepsilon_{jg},$$
$$(\uparrow \text{within each gene observations are iid / constant variance})$$

* `lmFit()` function in `limma` carries out multiple linear regression on each gene

* Usage: `lmFit(myDat, desMat)` 

  * `myDat` is a data frame or matrix with one row per observation (*G* genes by *N* samples)
  
  * `desMat` is a design matrix (output of `model.matrix(y ~ x)`; (*N* samples by $p$ parameters)
  
---


class: middle 

# Let's run `limma` for the interactive model with age

$$\Large y_{ijk} = \theta + \tau_{KO}x^{KO}_{ijk} + \tau_{Age}x^{Age}_{ijk} + \tau_{KO:Age}x^{KO}_{ijk}x^{Age}_{ijk}$$

---


## Formulating input for `lmFit`: gene expression data

```{r, include=FALSE}
library(dplyr)
library(ggplot2)

options(lifecycle_disable_warnings = TRUE)

myDes <- readRDS("data/GSE4051_design.rds")
levels(myDes$devStage)[levels(myDes$devStage)=="4_weeks"] <- "4W"

myDat<-read.table("data/GSE4051_data.tsv",
                      sep = "\t", header = T, row.names = 1)

myDes$Age <- ifelse(myDes$devStage == "E16", -4,
                 ifelse(myDes$devStage == "P2", 2, 
                     ifelse(myDes$devStage == "P6", 6, 
                        ifelse(myDes$devStage == "P10", 10, 28))))

```
.tiny[
```{r}
str(myDat)
```
]

---

## Formulating input for `lmFit`: covariate data

.pull-left[
.smaller[
```{r, linewidth=50}
head(myDes)
desMat <- model.matrix(~ gType*Age, 
                       data=myDes)
```
]]

.pull-right[
.tiny[
```{r}
desMat  
```
]]

---

# Computation is fast

<big>

```{r}
library(limma)
system.time(gFit <- lmFit(myDat, desMat))
```

* Using `lmFit` to fit an interactive model on 30K probesets takes a fraction of a second

* The time-intensive parts of an analysis lie in selecting the model and covariates, choosing how to parameterize it, and interpreting the output

---

# Output of `lmFit`


.pull-left[
.smaller[
```{r}
summary(gFit)
```
]
]

.pull-right[
.smaller[
```{r}
29949*4
```
]

]

---

# Output of `lmFit`

.pull-left[
.smaller[
```{r}
summary(gFit)
```
]
]

.pull-right[

.smaller[
```{r}
29949*4
```
]

* OK... but where are the shrunken variable estimates?? How do I pull out p-values??

* Actually, we haven't carried out the empirical Bayesian computation yet $\rightarrow$ need to run `eBayes()`!
]

---

# `eBayes()`

<div style= "float:left; position: relative; top: -40px;">
.tiny[
```{r}
summary(gFit)
```
]
</div>

<div style= "float:right; position: relative; top: -40px;">
.tiny[
```{r, highlight.output=c(14:24)}
summary(ebFit <- eBayes(gFit))
```
]
</div>

---

# Components of the empirical Bayes estimators

<center>

| math  | plain english  | `limma` | numerical result | also in `lm`? |
| :---: | :------------: | :-----: | :-----: | :---: |
| $s_g^2$ | gene-specific residual variance | `gFit$sigma^2` | 30K numbers | $\checkmark$ |
| $d$ | residual degrees of freedom $(n-p)$ | `gFit$df.residual` | $39-4=35^*$ | $\checkmark$ |
| $s_0^2$ | mean of inverse $\chi^2$ prior for $s_g^2$ | `ebFit$s2.prior` | `r signif(ebFit$s2.prior,2)` | |
| $d_0$ | degrees of freedom for the prior | `ebFit$df.prior` | `r signif(ebFit$df.prior,3)` | |
| $\tilde{s}_g^2$ | posterior mean of $s_g^2$ (i.e. moderated residual variance) | `ebFit$s2.post` |  30K numbers | |

<small><small>
$^*$ limma can handle more complicated models where this is not the same for each gene, so this is actually a vector of 30K copies of the number 35

---

### `topTable()` will help us extract relevant output in a convenient format!

<small><small><small>
<pre>
topTable(fit, coef=NULL, number=10, genelist=fit$genes, adjust.method="BH",
         sort.by="B", resort.by=NULL, p.value=1, lfc=0, confint=FALSE)
topTableF(fit, number=10, genelist=fit$genes, adjust.method="BH",
         sort.by="F", p.value=1, lfc=0)
</pre>

<table summary="R argblock">
<tr valign="top"><td><code>fit</code></td>
<td>
<p>list containing a linear model fit produced by <code>lmFit</code>, <code>lm.series</code>, <code>gls.series</code> or <code>mrlm</code>.
For <code>topTable</code>, <code>fit</code> should be an object of class <code>MArrayLM</code> as produced by <code>lmFit</code> and <code>eBayes</code>.</p>
</td></tr>
<tr valign="top"><td><code>coef</code></td>
<td>
<p>column number or column name specifying which coefficient or contrast of the linear model is of interest. For <code>topTable</code>, can also be a vector of column subscripts, in which case the gene ranking is by F-statistic for that set of contrasts.</p>
</td></tr>
<tr valign="top"><td><code>number</code></td>
<td>
<p>maximum number of genes to list</p>
</td></tr>
<tr valign="top"><td><code>adjust.method</code></td>
<td>
<p>method used to adjust the p-values for multiple testing.  Options, in increasing conservatism, include <code>"none"</code>, <code>"BH"</code>, <code>"BY"</code> and <code>"holm"</code>.
See <code><a href="../../stats/html/p.adjust.html">p.adjust</a></code> for the complete list of options. A <code>NULL</code> value will result in the default adjustment method, which is <code>"BH"</code>.</p>
</td></tr>
<tr valign="top"><td><code>sort.by</code></td>
<td>
<p>character string specifying statistic to rank genes by.
Possible values for <code>topTable</code> and <code>toptable</code> are <code>"logFC"</code>, <code>"AveExpr"</code>, <code>"t"</code>, <code>"P"</code>, <code>"p"</code>, <code>"B"</code> or <code>"none"</code>.
(Permitted synonyms are <code>"M"</code> for <code>"logFC"</code>, <code>"A"</code> or <code>"Amean"</code> for <code>"AveExpr"</code>, <code>"T"</code> for <code>"t"</code> and <code>"p"</code> for <code>"P"</code>.)
Possibilities for <code>topTableF</code> are <code>"F"</code> or <code>"none"</code>.
Possibilities for <code>topTreat</code> are as for <code>topTable</code> except for <code>"B"</code>.</p>
</td></tr>
</table>

...

<p><code>topTableF</code> ranks genes on the basis of moderated F-statistics for one or more coefficients.</p>
---

## `topTable` in action

<small>
* `coef` is the argument where you specify the coefficient you want to test for equality with zero

.small[
```{r}
topTable(ebFit, coef = "gTypeNrlKO")
```
]

* `topTable(ebFit, coef = 2)` is equivalent here, but much less informative!!

* this finds genes where the knockouts differ from the wild types *when age is zero*