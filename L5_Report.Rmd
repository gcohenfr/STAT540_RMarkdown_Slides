---
title: "Lecture 5: Two Group Comparisons and Statistical Inference"
author: "Gabriela Cohen Freue"
output: 
  html_document:
      toc: true
      toc_float:
        collapsed: false
        smooth_scroll: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo=FALSE}
library(lattice)
library(latticeExtra)
```

## Overview
In this lecture, you will learn about ...

**[LEARNING OBJECTIVES]**

- 1
- 2
- 3

**[R Dependencies]**

- lattice
- latticeExtra
- RColorBrewer

## Data description
We will be using the dataset from [SOURCE]

This dataset entails [DESCRIPTION]


### Loading the Data
```{r}
prDes <- readRDS("data/GSE4051_design.rds")
str(prDes)
```

```{r}
prDat<-read.table("data/GSE4051_data.tsv",
                      sep = "\t", header = T, row.names = 1)
str(prDat, list.len = 10)
```

Here we examine the design of the study with a frequency table. We have four samples for each combination of development stage and genotype (except for "E16 and NrlKO", which has 3 samples)

```{r}
with(prDes, table(devStage, gType))
```

A cursory glance at the experession data

```{r}
head(subset(prDat, select = 1:5))
```

### Subsetting the Data

Nrl (neural retina leucine zipper gene) is the gene that was knocked out in half the mice, and should obviously be differentially expressed. Nrl's probeset ID is "1450946_at". Irs4 (insulin receptor substrate 4) is selected as a boring non-differentially expressed gene. Irs4's probeset ID is "1422248_at".

We extract the rows for each of these genes, transpose and then vectorize the data. We then merge this data together with the design metadata. Ensure that the samples __match__ between the data and design before merging.

```{r}
miniDat <- as.vector(t(prDat[c("1422248_at", "1450946_at"), ]))
miniDat <- data.frame(gene = rep(c("Irs4", "Nrl"), each = nrow(prDes)),
                      gExp = miniDat)
miniDat <- data.frame(prDes, miniDat) # ignore the warning about row names
str(miniDat)
```

## Data visualization for two-group comparisons

We have a few options to visualize the differences in gene expression between genotypes. In each plot, we generate a panel for each gene.

```{r, echo=FALSE}

jCols <- c(x = "blue", y = "orange")
trellis.par.set(superpose.symbol = list(col = jCols),
                superpose.line = list(col = jCols))
jCex <- 3                               # used for sample means
```

### Strip plots

One option is to examine a strip plot. The first plot allows the x-axis scale to be freely set for each gene (dependent on the range of gene expression). The second plot forces both panels to have matching x-axis scales, which allows for between gene comparisons as well. The final plot let's us plot the mean values of gene expression for each gene and genotype.

```{r}

stripplot(gType ~ gExp | gene, miniDat,
          scales = list(x = list(relation = "free")),
          groups = gType, auto.key = TRUE,
          aspect = 0.5, layout = c(2, 1))

stripplot(gType ~ gExp | gene, miniDat,
          groups = gType, auto.key = TRUE,
          aspect = 0.5, layout = c(2, 1))

jFudge <- 0.35
stripplot(gType ~ gExp | gene, miniDat,
          grid = TRUE,
          scales = list(x = list(relation = "free")),
          groups = gType, jitter.data = TRUE,
          aspect = 0.5, layout = c(2, 1),
          panel = panel.superpose,
          panel.groups = function(x, y, ..., group.number) {
            yo <- group.number
            panel.stripplot(x, y, ...)
            theAvg <- mean(x)
            panel.points(theAvg, y[1], pch = "|", cex = jCex,
                         col = jCols[group.number])
            jLab <- substitute(paste(bar(Z), " = ", foo),
                        list(Z = c("Y", "Z")[group.number],
                             foo = round(theAvg, 2)))
            panel.text(x = mean(x), y = y[1] + jFudge,
                       jLab)
          })
```

### Density Plots

Another option is to examine a density plot. This plot let's us observe the distributions of gene expression, and how these distributions compare across genotype. The second plot is a "violin" plot, which provides a similar visualization as the density plot.

```{r}
densityplot(~ gExp | gene, miniDat,
            scales = list(x = list(relation = "free")),
            groups = gType, auto.key = TRUE)

bwplot(gType ~ gExp | gene, miniDat,
       scales = list(x = list(relation = "free")),
       panel = function(...) {
         panel.violin(..., col = "grey90")
         panel.stripplot(..., col = "black")
       })

```

### Boxplots

Boxplots may be another good choice. We can observe the median and IQR of our group distributions, as well as identify any outliers. The second plot combines a boxplot together with a "violin" plot

```{r}
bwplot(gType ~ gExp | gene, miniDat,
       scales = list(x = list(relation = "free")))

bwplot(gType ~ gExp | gene, miniDat,
       scales = list(x = list(relation = "free")),
       panel = function(..., box.ratio) {
         panel.violin(..., col = "transparent", border = "black",
                      varwidth = FALSE, box.ratio = box.ratio)
         panel.bwplot(..., fill = NULL, box.ratio = .1)
       })
```

## Statistical Inference

### Two group inference: t-tests

Now we're interested in testing whether we see a significant difference in mean gene expression between the wildtype and the NrlKO genotype. One option is to use a "two sample" t-test (sample here refers to the groups, not the individual samples). We compute the sample means for each genotype, for the two genes of interest. We then obtain the sample mean differences between wildtype and NrlKO for each gene. 

```{r}
## compute difference of sample averages
(theAvgs <- with(miniDat,
                 tapply(gExp, list(gType, gene), mean)))

(theDiff <- theAvgs["NrlKO", ] - theAvgs["wt", ])

```

Next, we compute the estimated variance of the difference between group sample means. We have two options here. One is that we can assume that the population variances of the two groups (the populations here being the wildtype and the NrlKO populations) are either inequivalent or equivalent. The following code computes both. The unequal variances option corresponds to the "Welch" two sample t-test.

```{r}
## compute sample variances
(theVars <- with(miniDat,
                 tapply(gExp, list(gType, gene), var)))

## compute estimated variance of zbar - ybar
(nY <- with(miniDat, sum(gType == "wt" & gene == "Nrl")))
(nZ <- with(miniDat, sum(gType == "NrlKO" & gene == "Nrl")))

## assuming unequal true variance
(s2DiffWelch <- colSums(theVars / c(nY, nZ)))

## assuming equal true variance
(s2Pooled <- colSums(theVars * c((nY - 1) / (nY + nZ - 2),
                                 (nZ - 1) / (nY + nZ - 2))))

(s2Diff <- s2Pooled * (1/nY + 1/nZ))
```

With the difference in means and our estimate of the variance of the difference between group sample means, we can compute the test statistic. In R, we can use the "t.test" function to compute the test statistic and perform the test for us. Our first tests are the Welch two-sample t-tests (in which we assume unequal group variances), and their results for both Irs4 and Nrl are shown below. Recall that our null hypothesis is that there is no difference in the sample means between the two groups. For each given test, we get a p-value for the test statistic based on the null sampling distribution. Notably, the tests corresponding to the Irs4 gene and Nrl gene have p-values of 0.6001 and nearly 0, respectively. This suggests a statistically significant difference in mean gene expression for Nrl, but not for Irs4.

```{r}
(welchStat <- theDiff / sqrt(s2DiffWelch))

by(miniDat, miniDat$gene, function(theDat) {
  ## to be compatible with the direction of the test, as I've described in
  ## lecture slides, I need to reverse order of levels of gType factor
  theDat$gType <- factor(theDat$gType, rev(levels(theDat$gType)))
  t.test(gExp ~ gType, theDat)
})
```

We perform the same tests, but this time assuming that the group variances are equal. The results are very similar. The test we choose to perform will depend on which assumption we want to make about the distributions of the group populations.

```{r}
(tstStat <- theDiff / sqrt(s2Diff))

by(miniDat, miniDat$gene, function(theDat) {
  theDat$gType <- factor(theDat$gType, rev(levels(theDat$gType)))
  t.test(gExp ~ gType, theDat, var.equal = TRUE)
})
```

Here we have the null distribution, where we overlay the t-distribution (red dotted line) with 37 degrees of freedom on top of the normal distribution (black line). In the subsequent plot, we examine the test statistic for Irs4 and where it lies on the distribution. The highlighted areas in blue is a visualization of our p-value, our measure of how likely we are to see a test statistic as or more extreme than what we observed.

```{r}
## draw the null dist'n

nullDistn <- data.frame(tVals = seq(-3.5, 3.5, length = 300))
nullDistn$densT <- dt(nullDistn$tVals, df = nY + nZ - 2)
nullDistn$densNorm <- dnorm(nullDistn$tVals)

with(nullDistn,
     matplot(x = nullDistn$tVals,
             y = nullDistn[c("densT", "densNorm")],
             type = "l"))

## depicting only for Irs4!

with(nullDistn,
     plot(densNorm ~ tVals, type = "l"))
abline(v = tstStat["Irs4"], lty = "dashed")

foo <- subset(nullDistn, tVals < tstStat["Irs4"])
polygon(x = c(foo$tVals, rev(foo$tVals)),
        y = c(rep(0, nrow(foo)), rev(foo$densNorm)),
        col = "blue")

polygon(x = -1 * c(foo$tVals, rev(foo$tVals)),
        y = c(rep(0, nrow(foo)), rev(foo$densNorm)),
        col = "blue")

round(pt(-1 * abs(tstStat), df = nY + nZ - 2) * 2, 5)
round(pnorm(-1 * abs(tstStat)) * 2, 5)
```

### Two group inference: Wilcoxon Rank Test

Another option to compare the distributions of gene expression between two groups is the Wilcoxon Rank Test. 

```{r}
(wilcTest <- by(miniDat, miniDat$gene, function(theDat) {
    wilcox.test(gExp ~ gType, theDat)
}))

## Warning messages:
## 1: In wilcox.test.default(x = c(7.867, 7.783, 7.585, 7.4, 7.667, 7.818,  :
##   cannot compute exact p-value with ties
## 2: In wilcox.test.default(x = c(8.761, 9.079, 10.61, 9.796, 11.39,  :
##   cannot compute exact p-value with ties

## hmmm..... there are *ties*? really?
by(miniDat, miniDat$gene, function(theDat) rank(theDat$gExp))
## yep, sure are, for both Irs4 and Nrl .... strange

## let's recreate the Wilcoxon test statistic
(jRankSums <- by(miniDat, miniDat$gene, function(theDat) {
    tapply(rank(theDat$gExp), theDat$gType, sum)
}))

(sampSize <- c(nY, nZ))

## from wilcox.text, we learn this: "The literature is not unanimous
## about the definitions of the Wilcoxon rank sum and Mann-Whitney
## tests.  The two most common definitions correspond to the sum of
## the ranks of the first sample with the minimum value subtracted or
## not: R subtracts and S-PLUS does not, giving a value which is
## larger by m(m+1)/2 for a first sample of size m."

sapply(jRankSums, function(foo) foo - sampSize * (sampSize + 1)/2)

## focus on the first row of that table -- the rank sums for wild type
## with the associated minimum subtracted

sapply(wilcTest, function(foo) foo$stat)

## Compare to output of the "official" test.
## See! we've computed the test statistic for ourselves.
```

```{r}
###############################################
## "two groups" inference: Kolmogorov-Smirnov
###############################################

## sadly, ks.test() has no formula interface

(ksTest <- by(miniDat, miniDat$gene, function(theDat) {
    ks.test(x = theDat$gExp[theDat$gType == "wt"],
            y = theDat$gExp[theDat$gType == "NrlKO"])
}))
## more moaning about the ties


## fodder for recreating the KS test stat by hand ... leaving for now
## THIS CODE WILL NOT WORK 'AS IS'!!

## foo <- ecdf(miniDat$gExp)

## x <- rnorm(12)
## Fn <- ecdf(x)
## Fn     # a *function*
## Fn(x)  # returns the percentiles for x
## tt <- seq(-2,2, by = 0.1)
## 12 * Fn(tt) # Fn is a 'simple' function {with values k/12}
## summary(Fn)
## ##--> see below for graphics
## knots(Fn)# the unique data values {12 of them if there were no ties}
## plot(tt, Fn(tt))

ecdfplot(~ gExp | gene, miniDat,
         scales = list(x = list(relation = "free")),
          groups = gType)

```

```{r}
###############################################
## direct support of first little bit of "beyond two groups" lecture
###############################################

## stripplot **for Irs4** by itself
stripplot(gType ~ gExp | gene, miniDat,
          subset = gene == "Irs4",
          groups = gType, auto.key = TRUE,
          aspect = 0.5)

## stripplot with sample means **for Irs4** by itself
jFudge <- 0.35
stripplot(gType ~ gExp | gene, miniDat,
          subset = gene == "Irs4",
          grid = TRUE, aspect = 0.5,
          groups = gType, jitter.data = TRUE,
          panel = panel.superpose,
          panel.groups = function(x, y, ..., group.number) {
            yo <- group.number
            panel.stripplot(x, y, ...)
            theAvg <- mean(x)
            panel.points(theAvg, y[1], pch = "|", cex = jCex,
                         col = jCols[group.number])
            jLab <- substitute(paste(bar(Z), " = ", foo),
                        list(Z = c("Y", "Z")[group.number],
                             foo = round(theAvg, 2)))
            panel.text(x = mean(x), y = y[1] + jFudge,
                       jLab)
          })

t.test(gExp ~ gType, miniDat,
       subset = gene == "Irs4", var.equal = TRUE)

summary(aov(gExp ~ gType, miniDat,
            subset = gene == "Irs4"))

summary(lm(gExp ~ gType, miniDat,
           subset = gene == "Irs4"))

## for pasting into slides
theAvgs
7.739684 - 7.765750
t.test(gExp ~ gType, miniDat,
       subset = gene == "Irs4", var.equal = TRUE)$stat
0.5286494 ^ 2
```